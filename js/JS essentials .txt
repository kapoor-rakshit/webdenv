
Ways of including JS
        0.     INTERNAL JS                                         // <script></script>
	0.     EXTERNAL JS                                         // <script src="path_to_js_file"></script>
	
	
Async/Defer attribute of SCRIPT tag
        0.     <script src="demo_async.js" async></script>         // If async is present: The script is executed asynchronously with the rest of the page (the script will be executed while the page continues the parsing)
	                                                           // If defer is present: The script is executed when the page has finished parsing
								   // If neither async or defer is present: The script is fetched and executed immediately, before the browser continues parsing the page


Array methods
        0.      var arr = ["Saab", " Volvo", "BMW"];
	0.      document.getElementById("#pid").innerHTML = arr;                              // returns comma separated values eg : Saab, Volvo,BMW
	0.      var arr4 = arr1.concat(arr2,arr3);                                            // just like "extend" in Python , new array returned with values of all.
	0.	a) var arr4 = [...arr1, ...arr2, ...arr3];                                    // similar to concat , use of ... (spread operator) 
	
		b) var arr = ['a', 'b', 'c'];
		   var arr2 = arr;                                                            // copyig arr using = will cause change to original arr as well as it pass by reference
		   function f(arr2) { }  f(arr);                                              // similarly in function call also, array object original value(s) will change
		   var arr2 = [...arr];                                                       // instead , we use spread operator which returns new array
		   
		c) var mx = Math.max([1,3,4]);                                                // using array in Math functions , return NaN
		   var mx = Math.max(...[1,3,4]);                                             // instead , we use spread operator
		   
		d) let data = {"name": "kapoor", "gender": "m"};			      // if object already has that key, it will be overwritten else new key added
		   data = {...data, "country": "india", "gender": "male"};		      // eg: data = {"name": "kapoor", "gender": "male", "country": "india"};
	0.      arr.fill("Balle", 2, 4);                                                      // fill array with value at index [start,end)     // modifies original array, plus return modified array
	0.      arr.filter(func_that_returns_true_false);                                     // just like "filter" in Python
	0.      arr.forEach(funcName);                                                        // calls function once for each element in order. // does not return
	0.      arr.map(funcName);                                                            // calls function once for each element in order. // returns new array with results of calling function
	0.	arr.every(funcName);							      // checks if all elements in array pass test (provided as a function).
											      // If it finds array element where function returns `false`, every() returns false 
											         and does not check remaining values , If no `false` occur, every() returns true
	0.	arr.some(funcName);							      // checks if any element in array pass test (provided as a function).
											      // If it finds array element where function returns `true` , some() returns true 
											         and does not check remaining values , Otherwise it returns `false`
	0.      Array.from("90254085RKTA");                                                   // just like "list()" in Python
	0.      arr.includes("chk",index_to_start_search);                                    // returns true/false if array contains the element.
	0.      arr.indexOf("chk", index_to_start_search);                                    // returns position, -1 if not found, -ve value index will search from that position from end till end
	0.      arr.lastIndexOf("chk", index_to_start_search);                                // returns position starting from end/index till beginning, -ve value index will search from that position from end till beginning
	0.      Array.isArray(arr);                                                           // returns true/false if object is array
	0.      arr.join("separator");                                                        // returns the array as a string with separator specified, else default (comma)
	0.      var newstr = arr.toString();                                                  //  returns a string with all the array values, separated by commas.
	0.      arr.length;                                                                   // returns number of elements in an array.
	0.      arr.pop();                                                                    // removes and return last element
	0.      arr.push("newelem");                                                          // adds new items to end of array, and returns new length.
	0.      arr.shift();                                                                  // removes and return first element
	0.      arr.unshift("val0", "val1");                                                  // adds new items to beginning of array, and returns new length.
	0.      arr.reduce(myFunc, initialVal);                                               // similar to "reduce" in Python // myfunc(accumVar, curVar) {return accumVar * curvar} , accumVar contains previous result or initialVal as applicable.
	0.      arr.reduceRight(myFunc, initialVal);                                          // similar to "reduce" but starts from right
	0.      arr.reverse();                                                                // modifies original array as reverse
	0.      var newarr = arr.slice(start,end);                                            // get all elem at index [start,end) as new array
	0.      arr.splice(start_adding_index, no_elem_to_remove, "Lemon", "Kiwi");           // adds/removes items to/from an array, and returns the removed item(s) if any.
	0.      var arr = arr.valueOf();                                                      // return the same array, the default method of the array object.
	0.      arr.sort();                                                                   // we can pass comparator function to it.
	0.	delete arr[index];                                                            // elem at index does not exist in arr (undefined) and donot change indexes of other elements.
	0.      arr.splice(index, 1);                                                         // start at index, remove 1 element, nothing new passed to add.
	0.	arr.flat(depth);							      // creates new array with all sub-array elements concatenated upto depth
											         // default depth = 1 | arr.flat(Infinity); | flat() removes empty slots
		
Shallow Copy | Deep Copy objects in JS
=========================================
	REFERENCE : https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089
	0.	Making a shallow copy of an array or object means creating new references to the primitive values inside the object, copying them.
		That means that changes to the original array will not affect the copied array, 
		which is what would happen if only the reference to the array had been copied (such as would occur with the assignment operator '=').
		NOTE : A shallow copy refers to the fact that only one level is copied, and that will work fine for an array or object containing only primitive values.
		1- Shallow copy using SPREAD OPERATOR (...)
		2- Shallow copy using SLICE METHOD (.slice())
		3- Shallow copy using ASSIGN METHOD (Object.assign())
		   eg: Object.assign(targetVAR, sourceVAR);
		4- Shallow copy using FROM METHOD (Array.from())
		   eg: let targetVAR = Array.from(sourceVAR);
		  
		Like other shallow copy methods, Array.from will make a shallow clone for arrays containing just values.
		But for deeply nested arrays that contain other arrays or objects, you need to deep copy, so Array.from won't work.
		
	0.	For objects and arrays containing other objects or arrays, copying these objects requires a deep copy. 
		Otherwise, changes made to the nested references will change the data nested in the original object or array too.
		1- Deep copy using lodash library ("low dash" i.e. "_")
		   > npm i lodash
		   eg: import { clone, cloneDeep } from "lodash";
		       let shallowCopyWithLodashClone = clone(sourceVAR);           // shallow copy , same as using spread operator
		       let deepCopyWithLodashCloneDeep = cloneDeep(sourceVAR);      // deep copy
		       
		2- Deep copy with Ramda
		   > npm i ramda
		   eg: import R from "ramda";
		       let deepCopyWithRamdaClone = R.clone(sourceVAR);             // deep copy
		       
		3- Deep copy with custom function
		   eg: const deepCopyFunction = (inObject) => {
                         let outObject, value, key

                         if (typeof inObject !== "object" || inObject === null) {
                           return inObject // Return the value if inObject is not an object
                         }

                         // Create an array or object to hold the values
                         outObject = Array.isArray(inObject) ? [] : {}

                         for (key in inObject) {
                           value = inObject[key]

                           // Recursively (deep) copy for nested objects, including arrays
                           outObject[key] = deepCopyFunction(value)
                         }

                         return outObject;
                      }  
		      let deepCopiedArray = deepCopyFunction(sourceVAR);
		      
		4- Deep copy with JSON.parse/stringify
		   // NOT RECOMMENDED as it might make a faulty clone
		   // NaN, Infinity values will be forced to 'null' | Date will get stringified | Undefined key-value pair will be completely lost
		   eg: const faultyClone = JSON.parse(JSON.stringify(sampleObject));
		   
		5- Deep copy with rfdc library
		   > npm i rfdc
		   eg: const clone = require('rfdc')()         // Returns the deep copy function
		       clone({a: 37, b: {c: 3700}})            // {a: 37, b: {c: 3700}}
	
	
Loops
	0.	For/In                                           // loops through the PROPERTIES (key) of an object
		// example
		var person = {fname:"John", lname:"Doe", age:25};
		for (let x in person) {
		    text += x;                                    // keys   - fname lname age
		    text += person[x];                            // values - John Doe 25   
		}
		
	0.	For/Of                                            // loops through the VALUES of an iterable objects
		// example                                        // such as Arrays, Strings, Maps, NodeLists, and more
		let map = new Map();
		map.set(1, "8.65");    map.set("key2", "val2");
		for (let i of map) {
		  document.getElementById("demo").innerHTML += i[0] + " " + i[1] + '<br/>';        // map = [[key1, val1], [key2, val2]] 
		}
		
	

Boolean
        0.      Boolean(10 > 9) | (10 > 9) | 10 > 9                                           // returns true
	0.      var x = true;     x = x.toString();                                           // converts Boolean to String


Date 
	0.	let dt = new Date();                                                          // Current Date Object | Fri Oct 18 2019 15:08:10 GMT+0530 (India Standard Time)
		let dt = new Date(year, month, day, hours, minutes, seconds, milliseconds);   // 7 numbers (in that order) | January is 0. December is 11.
		let dt = new Date(year, month, day, hour, minute, second);		      // 6 numbers
		let dt = new Date(year, month, day, hour, minute);			      // 5 numbers
		let dt = new Date(year, month, day, hour);                                    // 4 numbers
		let dt = new Date(year, month, day);                                          // 3 numbers
		let dt = new Date(year, month);                                               // 2 numbers
		let dt = new Date(milliseconds);                                              // 1 number, treated as milliseconds
		let dt = new Date("2020-05-17");  					      // "dateString (YYYY-MM-DD)" or (YYYY/MM/DD) as arg
		let dt = new Date("05-17-2020");					      // "dateString (MM/DD/YYYY)" or (MM-DD-YYYY) as arg
		let dt = new Date("2020-05");						      // "dateString (YYYY-MM)" as arg
		let dt = new Date("2020");						      // "dateString (YYYY)" as arg
		let dt = new Date("2020-05-17T12:00:00");                                     // "dateString (YYYY-MM-DDTHH:MM:SS)" as arg | T - Separator for Date and time
		let dt = new Date("2020-05-17T12:00:00Z");                                    // "dateString (YYYY-MM-DDTHH:MM:SSZ)" as arg | Z - UTC Time
		let msec = Date.parse("2020-05-17");                                          // convert valid date string to milliseconds ie difference from January 1, 1970
	0.      dt.getDay();                                                                  // DAY_OF_WEEK  , (0 [Sunday] to 6)
	0.      dt.getMonth();                                                                // MONTH        , (0 [January] to 11)
	0.      dt.getDate();                                                                 // DAY_OF_MONTH , (1 to 31)
		dt.setDate(dt.getDate() + 15);                                                // If the month has 30 days, 32 as arg will result in second day of next month
	0.      dt.getFullYear();                                                             // YEAR (four digits for dates between year 1000 and 9999)
	0.      dt.getHours();                                                                // HOURS        , (0 to 23)
	0.      dt.getMinutes();                                                              // MINUTES      , (0 to 59)
	0.      dt.getSeconds();                                                              // SECONDS      , (0 to 59)
	0.      dt.getMilliseconds();                                                         // MILLISECONDS , (0 to 999)
	0.      dt.toDateString();                                                            // date (not the time) of Date object into readable string. eg: Fri Oct 18 2019
	0.      dt.toTimeString();                                                            // time portion of a Date object to a string. eg: 16:06:10 GMT+0530 (India Standard Time)
	0.      dt.toLocaleTimeString();                                                      // time portion of a Date object as a string, using locale conventions. eg: 4:01:43 PM
	0.      dt.getTime();                                                                 // milliseconds between midnight of January 1, 1970 and the specified date object.
	0.      var n = Date.now();                                                           // milliseconds between midnight of January 1, 1970 and the specified date object.
	0.      dt.getUTCDay();                                                               // UTC DAY_OF_WEEK  (0 [Sunday] to 6)
	0.      dt.getUTCMonth();                                                             // UTC MONTH        (0 [January] to 11)
	0.      dt.getUTCDate();                                                              // UTC DAY_OF_MONTH (1 to 31)
	0.      dt.getUTCFullYear();                                                          // UTC YEAR
	0.      dt.getUTCHours();                                                             // UTC HOURS
	0.      dt.getUTCMinutes();                                                           // UTC MINUTES
	0.      dt.getUTCSeconds();                                                           // UTC SECONDS
	0.      dt.getUTCMilliseconds();                                                      // UTC MILLISECONDS
	0.      dt.toUTCString();                                                             // date object to a string, according to universal time. eg: Fri, 18 Oct 2019 10:38:48 GMT
	

Exception Handling
        0.      try {
	          adddlert("Welcome guest!");                                                 // this will generate builtin error object
		 
		  if(x == "")  throw "empty";                                                 // throw error explicitly
		  if(isNaN(x)) throw "not a number";
		  x = Number(x);
		  if(x < 5)  throw "too low";
		  if(x > 10)   throw "too high";
		}
		catch(errobj) {
		  if(errobj.message == undefined) {                                          // check if errorobj is builtin or explicit
		   document.getElementById("demo").innerHTML = errobj;
		  }
		  else {
		   document.getElementById("demo").innerHTML = errobj.name + " " + errobj.message;       // name/message of builtin obj
		  }
		}
		finally {
		 
		}
		
		
Misc.
	0.	Native objects | Host objects
		Native objects are part of JavaScript language defined by ECMAScript specification, such as String, Math, Object, Function etc.
		Host objects are provided by runtime environment (browser or NodeJS server), such as window, XMLHTTPRequest etc.
		
	0.	Window is JavaScript's root object, also called Global Object in a browser or it is a root of DOM, accessed as window.<PROPERTY>
		NOTE : Since `window` is a global object, we can reference any <PROPERTY> directly i.e. without using `window.<PROPERTY>`
		`window.screen`  or just `screen` is a small information object about physical screen dimensions.
		`window.document` or just `document` is object about visible or rendered DOM.
	
        0.      In regular functions the 'this' keyword represents the object that called the function.
		With arrow functions the 'this' keyword represents the scope same as scope of it's parent, where arrow function is defined.
		In a object's method, 'this' refers to the owner object or owner of method.
		Alone, 'this' refers to the global object. In a browser window the Global object is [object Window].
		In setTimeout()/setInterval() callback func 'this' keyword refers to window (or global) object.
		Example
		0. // Regular Function
		   hello = function() {
		             document.getElementById("demo").innerHTML += this;      // two different objects (window and button)
			   }
	           // The window object calls the function
		   window.addEventListener("load", hello);
		   
		   // A button object calls the function
		   document.getElementById("btn").addEventListener("click", hello);
		   
		0. // Arrow Function
		   hello = () => {
		            document.getElementById("demo").innerHTML += this;       // window object twice, because window object is  "owner" of function.
			   }
		   // The window object calls the function
		   window.addEventListener("load", hello);
		   
		   // A button object calls the function
		   document.getElementById("btn").addEventListener("click", hello);
		   
		0. // Object's Method
		   var person = {
		      firstName: "John",
		      lastName : "Doe",
		      id       : 5566,
		      fullName : function() {
		         return this.firstName + " " + this.lastName;
		      }
		   };
		   
		0. // an Example, from Deloitte interview
		   const a = {
		   	one : function(){
				console.log(this);
			},
			two : () => {
				console.log(this);
			},
			three: () => {
				this.two();
			},
			four: function() {
				this.two();
			}
		   }
		   a.one();   // [Object object]
		   a.two();   // [Object window]
		   a.three(); // ERROR : this.two is not a function , two() in not defined in window scope and stops program execution
		   a.four();  // [Object window]
		   
		0. // setTimeout()/setInterval()
		   setTimeout(myMethod, 1000);         // prints "[object Window]" after 1 second for `this` inside myMethod callback
		   
	0.      var res = encodeURI("https://w3schools.com/my test.asp?name=ståle&car=saab");            // encodes special characters, except: , / ? : @ & = + $ #
	        var dec = decodeURI(enc);
	0.      var res = encodeURIComponent("https://w3schools.com/my test.asp?name=ståle&car=saab");   // encodes special characters. In addition, it encodes: , / ? : @ & = + $ #
	        var uri_dec = decodeURIComponent(uri_enc);
	0.	let enc = btoa(str);                                                                     // btoa() method encodes a string to base-64
		let dec = atob(enc);                                                                     // atob() method decodes a base-64 encoded string
	
	0.      var b = eval("2 + 2");                                                                   // evaluates expression or executes JS statements.
	
	0.	Logical nullish operator (??)
		1> x ??= y   OR   x ?? (x = y)  , evaluates (x = y) if x is nullish (null or undefined).
		2> console.info(`${a ?? b}`);   , prints b if a is nullish else prints a.
		
		Optional chaining operator (?.)
		1> let obj = {"k1": null};
		   console.info(obj.k1?.k2);    , stops evaluating when reference (k1) is nullish and returns `undefined`
		   console.info(obj.k1.k2);     , exception thrown : Uncaught TypeError: Cannot read property 'k2' of null
	
	0.	[x,y] = [y,x]                                                                            // swap values , similar to as in python
	0.	function f() { return [9025, 67, 56, 4021]; }                                            // return multiple vals using []
	        [a,,b] = f();                                       // capture multiple vals using [] | NOTE : a=9025 , b=56 (not 67) | extra vals ignored
	
	0.      Infinity when a number exceeds the upper limit of the floating point numbers, which is 1.797693134862315E+308.
	       -Infinity when a number exceeds the lower limit of the floating point numbers, which is -1.797693134862316E+308.
	       
	0.      isNaN("9025");                                                                          // converts arg to a Number, then tests it.  "9025" and 9025 both give false as ther are Number   // this is different from Number.isNaN();
	0.      Number(true)                                                                            // converts arg to number. If value cannot be converted to legal number, NaN is returned.
	
	0.      var c = parseFloat("10.33");                                                            // 10.33
	0.      var c = parseInt("10.33");                                                              // 10
	        var h = parseInt("10", 8);                                                              // 8 (octal , second arg 8 passed)
		var j = parseInt("20", 16);                                                             // 32 (hexadecimal , second arg 16 passed)
		
	0.      String(x)  ==  x.toString();                                                            // typecast to string
	
	0.      if (typeof y === "undefined") {                  // typeof , "undefined"|"string"|"number"|"boolean"|"object"|"function"
	          txt = "y is undefined";                        // NaN is           "number"
		}                                                // Array , Date are "object"
		                                                 // null is          "object"
								 // undefined is     "undefined"
								 // NOTE : null == undefined         // true ,  as same in value
								         : null === undefined        // false , different in type
		
	0.      <a href="javascript:void(0);">Useless link</a>               // The void operator evaluates an expression and returns undefined.
	                                                                     // This operator is often used to obtain the undefined primitive value, using "void(0)".
		<a href="javascript:functionName(arg)">FunctionCall link</a>  // call to a function "functionName"
	        <a href="javascript:void(document.body.style.backgroundColor='red');">Change background color of body to red</a>
		                                                             // (this is useful when evaluating an expression without using the return value).
									     
	0.	document.getElementById("myDropdown").selectedIndex = -1;    // prevents first value of <select>'s <option> to be selected 
	
	
	
enum
	0.	// Enums allow us to define a set of named constants. TypeScript provides both numeric and string-based enums.
		// 1
		export enum Direction {
		   Up = 1,                            // if not specified any value, it will be 0
		   Down,                              // values for each key increments (if numeric) by 1 from previous value,  down = 2
		   Left,                              // left = 3
		   Right,                             // right = 4
		}
		
		// 2
		export enum EmployeesActionTypes {
		   SHOW_COMPANY_NAME = 'SHOW_COMPANY_NAME',
		   ADD = 'ADD',
		   DELETE = 'DELETE'
		}
	
	
JavaScript Hoisting
	0.	// Hoisting is JavaScript's default behavior of moving DECLARATIONS to the top of the current scope i.e. 
	           (to the top of the current SCRIPT|GLOBAL SCOPE or the current FUNCTION SCOPE.
		// a variable can be initialized and used (x = 5) before it has been declared (var x).
		// JavaScript only hoists DECLARATIONS, not INITIALIZATIONS.
		// To avoid bugs, always declare all variables at the beginning of every scope.
		   JavaScript in strict mode ("use strict") does not allow variables to be used if they are not declared.
		// Example
		0. var x = 5;
		   console.log(`${x} ${y}`);      // x = 5 , y = undefined
		   var y = 7;
		                                  ------ same as above because of HOISTING --------
		0. var x = 5;
		   var y;                         // DECLARATIONS (not INITIALIZATIONS) move to top of a scope because of HOISTING
		   console.log(`${x} ${y}`);      // x = 5 , y = undefined
		   y = 7;
		                                  ------ scope is only for function and script , not for if|else|loop scope ------
		0. y = 5;
		   function f(){
		     if(<CONDITION>){
		       var y;                     // declaration within if block scope , but it is HOISTED to function scope
		       console.log(`${y}`);       // y = undefined because y is HOISTED within scope of function , not using global scope
		     }
		       console.log(`${y}`);       // y = undefined because y is HOISTED within scope of function , not using global scope
		   }
		   var y;
		   
		0. y = 5;
		   function f(){
		     var y = 9025;
		     if(<CONDITION>){
		       var y = 4084;             // This declaration will be HOISTED to FUNCTION SCOPE
		       console.log(`${y}`);      // y = 4084
		     }
		       console.log(`${y}`);      // y = 4084 , not 9025 because var y = 4084 | var y = 9025 get merged as var y = 9025 to top of FUNCTION
		   }
		   
		0. var i = 5;
		   for (var i = 0; i < 10; i++) {        // this variable gets merged with above scope for declaration but inited as 0
		     // some statements
		   }
                     // Here i is 10              
		   
	0.	// A variable declared without any keyword becomes global even if initialized inside a function|loop|if|else block
		// Example
		0. function f(){
		     if(<CONDITION>){
		       z = 15;
		     }
		   }
		   console.log(`${z}`);             // z = 15 , as it is global because initialized without keyword 'var'
		   
	0.	// Keywords 'let' and 'const' provide BLOCK SCOPE (and constants) instead of GLOBAL SCOPE | FUNCTION SCOPE with 'var'
	           i.e. they are not HOISTED
	        // 'let' keyword do not belong to the window object i.e. we cannot use window.VARIABLE which is declared with 'let'
		// Redeclaring 'var' variable with 'let' or vice-versa | 'let' variable with 'let' | global variable (without any keyword) with 'let' is not allowed
		// Example
		0. function f(){
		     var y = 9025;
		     if(<CONDITION>){
		       let y = 4084;                // provides a BLOCK SCOPE because of 'let'
		       console.log(`${y}`);         // y = 4084
		     }
		       console.log(`${y}`);         // y = 9025
		   }
		   
	0.	// Variables defined with 'const' behave like 'let' variables, except they cannot be reassigned.
		// 'const' variables must be assigned a value when they are declared else will give an error.
		// It does NOT define a constant value. It defines a constant reference to a value.
		   Because of this, we cannot change constant primitive values, but we can change the properties of constant objects.
		   Example
		   0. const car = {type:"Fiat", model:"500", color:"white"};
		      const cars = ["Saab", "Volvo", "BMW"];

		      car.color = "red";                                         // MODIFY
		      cars[0] = "Toyota";

		      car.owner = "Johnson";                                     // ADD NEW PROPERTY | VALUE
		      cars.push("Audi");
		      
		      car = {type:"Volvo", model:"EX60", color:"red"};           // ERROR
		      cars = ["Toyota", "Volvo", "Audi"];                        // ERROR
		      
	0.	// Function Hoisting
		// Unlike variables, a function declaration doesn't just hoist the function's name. 
		   It also hoists the actual function definition.
		// However, function definition hoisting only occurs for function declarations, not function expressions.
		   because VARIABLES only have their DECLARATIONS hoisted , not INITIALIZATIONS.
		// Example
		0. definitionHoisted();                                           // Outputs: "Definition hoisted!"
		   definitionNotHoisted();                                        // TypeError: undefined is not a function
		   funcname();                                                    // ReferenceError: funcName is not defined
		   
		   function definitionHoisted() {                                // function declaration plus definition
		     console.log("Definition hoisted!");
		   }
		   
		   var definitionNotHoisted = function funcname() {              // function expression in a VARIABLE
		     console.log("Definition not hoisted!");
		   };
		      
		      
JavaScript Use Strict
	0.	// "use strict";     Defines that JavaScript code should be executed in "strict mode".
		// Strict mode makes it easier to write "secure" JavaScript.
		   Strict mode changes previously accepted "bad syntax" into real errors.
		// NOTE : The "use strict"; directive is only recognized at the beginning of a script or a function.
		   Example
		   0. "use strict";
		      myFunction();
		      function myFunction() {
		         y = 3.14;                       // This will also cause an error because y is not declared
		      }                                  // if strict not used , it will create a new global variable for y
		      
		   0. x = 3.14;                          // This will not cause an error.
		      myFunction();
		      function myFunction() {
		         "use strict";
			 y = 3.14;                       // This will cause an error
		       }
	

Debugging
        0.     // activate debugging in your browser with the F12 key, and select "Console" in the debugger menu.
	0.     // use console.log() to display JavaScript values in the debugger window
	0.     // The "debugger" keyword stops the execution of JavaScript, and calls (if available) the debugging function.
	          // This has the same function as setting a breakpoint in the debugger on sources tab window on browser
	0.     var x = 15 * 5;    debugger;     document.getElementById("demo").innerHTML = x;


Number
	0.	Number.MAX_VALUE;
	0.      Number.MIN_VALUE;
	0.      Number.NEGATIVE_INFINITY;
	0.      Number.POSITIVE_INFINITY;
	0.      var n = num.toExponential(3);      // number into an exponential notation 23.4568  -->  2.346e+1 coz after decimal 3 reqd
	0.      var n = num.toFixed(2);            // Convert number into string, keeping specified decimals or 0 if reqd after decimal
	0.      var n = num.toPrecision(5);        // Format a number to a specified length   13.67890  -->  13.679
	0.	Number.isNaN(NaN)                  // true (here) only on "NaN" arg else false ('NaN' as string is also false)
	                                           // This is different from global isNaN() function converts the tested value to a Number, then tests it.
						   
Regex
        0.      // Syntax   :   /pattern/modifiers               eg:  var patt = /w3schools/i;
	0.      // MODIFIERS
	           g    Perform a global match (find all matches rather than stopping after the first match)
	           i    Perform case-insensitive matching
		   m	Perform multiline matching               eg:  var str = "\nIs th\nis it?";   var patt1 = /^is/m;
	0.      // The exec() method tests for a match in a string, returns matched text if finds match, otherwise returns null.
	           var patt2 = /W3Schools/g;     var result2 = patt2.exec(str);
	0.      // test() method tests for a match in a string, returns true if it finds a match, otherwise it returns false.
	           var patt = /Hello/g;          var result = patt.test(str);
	0.      var res = str.match(/ain/g);                      // returns the matches, as an Array object  or  null
	0.      var res = str.replace(/blue/g, "red");            // values are replaced
	0.      var n = str.search(/blue/i);                      // returns the position of the pattern
	
	
Strings
        0.      var res = str.length                       // length of string
	0.      var res = str.charAt(index)                // character at the specified index (position)
	0.      var res = str1.concat(str2, str3);         // concatenate multiple strings
	0.      str.endsWith();                            // Checks whether string ends with specified string/characters
	0.      str.startsWith();                          // Checks whether string starts with specified string/characters
	0.      str.includes("chk", start);                // Checks whether string contains the specified string/characters
	0.      var res = str.indexOf("chk", start);       // Returns position of first found occurrence of specified value in string
	0.      var res = str.repeat(2);                   // conacatenate str specified number of times to itself
	0.      var res = str.slice(start, end);           // get array elems [start,end) index
	0.      var res = str.substring(start, end);       // get array elems [start,end) index
	0.      var res = str.substr(start, chars_reqd);   // get array elems [start,start + chars_reqd) index
	0.      var res = str.split(" ", limit);           // Splits a string into an array of substrings , with limit specified , not included in res after limit
	0.      var res = str.toLowerCase();
	0.      var res = str.toUpperCase();
	0.      var res = str.trim();
	0.	var res = String.fromCharCode(65,67);      // returns AC , just like chr() in python  |  NOTE : String object
	0.	var res = str.charCodeAt(index);           // returns 65 if char at index is A of string str , just like ord() in python


Form
	0.	document.<NAME_ATTRIB_OF_FORM>.<NAME_ATTRIB_OF_WIDGET>.value;                       // set or get value.
	        document.forms.namedItem("<ID_ATTRIB_OF_FORM>").<NAME_ATTRIB_OF_WIDGET>.value;
		document.getElementById("<ID_ATTRIB_OF_FORM>").<NAME_ATTRIB_OF_WIDGET>.value;
		
	0.	onsubmit=“return validate()”.                       // return false from func if error else true     OR
	                                                            // when it return false - form will not submit and will not redirect too
								       It means Do nothing. Return the control flow. Stops submission of form
								    // when it return true - form will submit and will redirect as  mentioned in action



Functions
	0.	var f = function(a, b) { return a*b; }              // anonymous function stored in variable f | args passed without var keyword before them
                    f (45, 5);                                      // invoke function stored in variable f
		    
	0.      var f = function(a=1, b=0) { return a*b; }          // default values passed to function incase not passed on invoke
	
	0.      (function () {                                      // IIFE (Immediately Invoked Function Expression), also called
	            var x = "Hello!!";                              // anonymous self-invoking function , NOTE : () around and after function
		})();
		
		(function (user) {                                  // IIFE with passed parameter
	            var x = "Hello!!" + user;
		})("kapoor-rakshit");
		
	0.      const x = (x, y) => { return x * y };               // Arrow Functions in ES6
		                                                    // syntax | `arguments` keyword not valid | `this` keyword context | no duplicate named param allowed
	
	0.      function findMax() {                                // findMax(4, 5, 6) is called without using args in definition  // uses built-in "arguments" object.
	            var i;
		    var max = -Infinity;
		    for(i = 0; i < arguments.length; i++) {
		        if (arguments[i] > max) {
			    max = arguments[i];
			    }
			 }
		     return max;
		 }
		 
	0.	function f(a,b,...c){                            // Rest parameter
	          // statements                                  // a="kapoor" , b="rakshit" , ...c catches remaining arguments as an array
	        }                                                // without rest parameter c="Kolkata" , remaining args are ignored
		f("kapoor","rakshit","Kolkata","Hyderabad","Pune","Bangalore","Delhi","Greater Noida");
		
	0.	function f(a,b,c){                                // Spread Operator
		  // statements                                   // a=arr[0] , b=arr[1] , c=arr[2]
		}                                                 // if arr has more vals than args required , they are ignored
		f(...arr);
		
	0.	function f() { return [9025, 67, 56, 4021]; }     // return multiple vals using []
	        [a,,b] = f();                                     // capture multiple vals using [] | NOTE : a=9025 , b=56 (not 67) | extra vals ignored
		
	0.      var add = (function () {                          // JS Closures , a function having access to parent scope, even after parent function has closed.
	             var counter = 0;
		     return function () {counter += 1; return counter}   
		})();                                             // self-invoking function only runs once. It sets counter to zero (0)
		                                                  // and returns a function expression to variable add whuich can be invoked
                add();
		
	0.      var obj = {"first" : "kapoor" ,                     // function() as a value to key in object  /* call function as obj.full("-") , NOTE : use of () in obj.full() (not obj.full) */
                          "second" : "rakshit" ,
                          "full" : function(sep){
                            return this.first + sep + this.second;
                          }};                   
			  
	0.      var obj = {firstName: "John",                       // getter inside object using "get" keyword   /* call getter as obj.lang , NOTE : no use of () in getter */
                           lastName : "Doe",
                           language : "en",
                           get lang() {
                              return this.language.toUpperCase();
                            }};                       
			    
        0.      var obj = {firstName: "John",                       // setter inside object using "set" keyword  /* call setter as obj.lang = "en"; */
                           lastName : "Doe",
                           language : "",
                           set lang(lang) {
                              this.language = lang.toUpperCase();
                            }};
			    
	0.	Object.seal() | Object.freeze()
		   The Object.seal() method seals an object, preventing new properties from being added or existing from being deleted.
		   Values of present properties can still be changed.
		   Eg: Object.seal(obj);
		   
		   The Object.freeze() method freezes an object. A frozen object can no longer be changed.
		   freezing an object prevents new properties from being added to it, existing properties from being removed.
		   Values of existing properties CANNOT be changed.
		   Eg: Object.freeze(obj);
			    
	0.	.call()  |  .apply()  |  .bind()
		   They can be used to invoke method with owner object as argument i.e. an object can use a method/props belonging to another object.
		   The difference between them is .call() method takes arguments separately | .apply() method takes arguments as an array.
		   var person = {
		      fullName: function(city, country) {
		         return this.firstName + " " + this.lastName + "," + city + "," + country;
		      }
		   }
		   var person1 = {
		      firstName:"John",
		      lastName: "Doe"
		   }
		   Eg:
		   let callData = person.fullName.call(person1, "Oslo", "Norway");
		   let applyData = person.fullName.apply(person1, ["Oslo", "Norway"]);
		   
		   Unlike the call() and apply() methods, the bind() method doesn’t immediately execute the function. 
		   It just returns the function.
		   Eg:
		   let f = person.fullName.bind(person1, "Oslo", "Norway");
		   setTimeout(f, 1000);
			    
	0.      // ES5
		// Constructor , a convention to distinguish ordinary function and constructor write FunctionName as Capitalized
		function Person(first, last, age, eye) {
	          this.firstName = first;
		  this.lastName = last;
		  this.age = age;
		  this.eyeColor = eye;
		  this.nationality = "Amritsari";                   // default property to all objects of this constructor
		  this.changeFirstName = function(arg){
		      this.firstName = arg;                         // function to return/change inside constructor
		      };
		 }                                /* object created as , var myFatherObj = new Person("Anil", "Kapoor", 50, "black"); */
		                                  /* object used as    , myFatherObj.nationality, myFatherObj.age, .... */
	0.     Person.prototype.gender = "Male";                    // All JS objects inherit properties and methods from a prototype.
	                                                            // We can add new properties using prototype.
	0.	// ES2015 or ES6 , make use of CLASS
		// A class is a type of function, but instead of using the keyword function to initiate it, we use the keyword class,
		   and the properties are assigned inside a constructor() method.
		   if you do not have a constructor() method, JavaScript will add an invisible and empty constructor method.
		// Example
		0. class Car {
		        naam = "kapoor-rakshit";                       // this is similar to initialize inside a constructor , this.naam
		     constructor(brand) {                              // constructor initialized when class initiated
		        this.carname = brand;                          // variables are declared using "this" keyword
		     }
                     present(x) {                                      // another method , NOTE : donot use "function" keyword
		        return `${x} I have a ${this.carname}`;
		     }
		   }
		    mycar = new Car("baleno");                         // initialize object for class
		    mycar.present("Namaste");
		    
		 0. // Static methods and variables
		    // Static methods are defined on the class itself, and not on the prototype.
		       That means you cannot call a static method on the object (mycar), but on the class (Car.STATIC_METHOD)
		    // Being called on class , it does not access values for properties initialized in constructor , so we pass object to this static method
		    // we cannot access STATIC_METHOD from NON_STATIC_METHOD plus vice-versa.
		    // a STATIC_VARIABLE is accessed using class (Car.STATIC_VARIABLE) not object or from only inside a STATIC_METHOD (this.STATIC_VARIABLE)
		    // Example
		    class Car {
		      constructor(brand) {
		         this.carname = brand;
		      }
		      static hello(obj){
		         return `${obj.carname} is my car`;
		      }
		    }
		      mycar = new Car("swift");
		      console.log(Car.hello(mycar));                    // we can also send class's object as parameter to static method
		      
		  0. // Inheritance
		     // To create a class inheritance, use the extends keyword.
		     // call to constructor of Parent|Base class using 'super()' keyword which is to be called before accessing 'this' statement.
		     // call to parent method using 'super.METHOD()' that have same names , else use 'this.METHOD()'.
		     // NOTE : we CANNOT use 'super.VARIABLE' for accessing parent variable values that have same names.
		               to access variables use 'this.VARIABLE'  or  parent method call that returns parent variable
		     // Example
		     class Car {
		       constructor(brand) {
		          this.carname = brand;
		       }
		       show () {
		          return `${this.carname} is my car`;
		       }
		     }
		     class Model extends Car {
		       constructor(brand, model) {
		          super(brand);
			  this.model = model;
		          this.carname = brand;                            // this will Override value of VARIABLE as same name used , 
			                                                   // it will also override value for parent class variable 
							 // to check , call the method from Child|Derived class of parent class that use VARIABLE (carname)
		       }
		       show () {                                           // this will Override the parent method , as expected
		          return `my car is ${this.carname} , ${this.model}`; 
		       }
		     }
		       mycar = new Model("baleno", "delta BS VI");
		       mycar.show();
		       
		 0. // Getter | Setter
		    // Example
		    class Car {
		      constructor(carVal) {
		        this.carname = carVal;
		      }
		      get getCarName() {
		        return `${this.carname}`;
		      }
		      set setCarName(carParam) {
		        this.carname = carParam;
		      }
		    }
		      mycar = new Car("Baleno");
		      mycar.setCarName = "Swift";
		      mycar.getCarName;
		      
Map
	0. In ES6 or ES2015 , Map object is provided which is a collection of elements where each element is stored as a Key, value pair. 
	   When we iterate over the map object it returns the key,value pair in the same order as inserted.
	   // Example
	   // myMap = [["Ram", "Chennai"], [9025, "Pune"], ["Vinay", "Bangalore"]];
	   let myMap1 = new Map();
	   myMap1.set("Ram", "Chennai");                // [key, value]
	   myMap1.set(9025, "Pune");
	   myMap1.set("Vinay", "Bangalore");
	   
	   myMap1.size;                                 // size of map
	   
	   myMap1.has(key);                             // returns boolean if key present or not
	   
	   myMap1.get(key);                             // get value using key
	   
	   myMap1.delete(key);                          // delete both the key as well as a value from the map
	   
	   myMap1.clear();                              // Removes all the elements from the Map object
	   
	   let mapArr = myMap1.entries();               // Returns an iterable as [[key1, val1] , [key2, val2], .....]
	   
	   let mapKeyArr = myMap1.keys();               // Returns an iterable for keys
	   
	   let mapValArr = myMap1.values();             // Returns an iterable for values
	   
	   myMap1.forEach(functionName);                // provides a function to be executed for each key-val pair
	   function functionName(value, key) { }        // functionName definition , first param is value, second is key for each pair
	  
Set
	0. let tpStr = "kapoor-rakshit";
	   let mySet1 = new Set(tpStr);

           let tpArr = ["kapoor", 45, "rakshit", 9025, "kapoor", 9025];
	   let mySet2 = new Set(tpArr);

	   let mySet3 = new Set();
	   mySet3.add(9025); mySet3.add(4095); mySet3.add(4095); mySet3.add(4021); mySet3.add(9025);

	   mySet3.size;

	   mySet3.has(val);

	   mySet3.delete(val);

	   mySet3.clear();

	   let getEntriesArry = mySet3.entries();       // [[val, val], [val, val]]

	   let getKeys = mySet3.keys();                 // {val, val}

	   let getValues = mySet3.values();             // {val, val}

	   mySet3.forEach(callbackFn);                  // provides a function to be executed for each key-val pair
	   function callbackFn(key, values, set) { }    // callbackFn definition , key - val - setObject

	   setA.subSet(setB);                           // returns true if Set A is a subset of Set B
		                                        // Set A is said to be subset of Set B, if all elements of Set A are present in Set B

	   setA.union(setB);                            // union i.e. all distinct from both sets i.e. setA + setB

	   setA.intersection(setB);                     // intersection i.e. common elements

	   setA.difference(setB);                       // newSet = setA - setB
	   
		      
Export | Import   functions/classes
	0. ES6 or ES2015 is the first time that JavaScript has built-in modules.
	   ES6 modules are stored in files. There is exactly one module per file and one file per module.
	   
	   
	0. /* In index.html */
	   /* define a <script> tag with type="module" and src="<MODULE_js_file>" (js file that has imports) attribute */
	      <script type="module" src="./main.js"></script>
	      
	   /* Prior to ES2015 or ES6 , we need to use webpack to bundle all .js in one /dist/bundle.js */
	      > webpack --mode=development                         // creates a file 'bundle.js' inside directory /dist
	      <script src="/dist/bundle.js"></script>           
	      

	0. NOTE : Imports are hoisted
	          Module imports are hoisted (internally moved to the beginning of the current scope). 
		  Therefore, it doesn’t matter where you mention them in a module.
		  
		  /* 1. import default export function in module js file */
		     import <ANY_ARBITRARY_NAME> from './math.js';
		     <ANY_ARBITRARY_NAME>();                       // call to default export

		  /* 2. import named export functions in module js file , NOTE : use of { } in import statement */
	          /*    we can also provide alias to named export function */
   	             import { subtract as <ALIAS>, multiply, divide, square } from './math.js';
   		     <ALIAS>();     multiply();    square();       // call to named export

		  /* 3. import all exports (default plus named) in module js file */
   		     import * as <ALIAS_NAME> from './math.js';
      		     <ALIAS_NAME>.default();                       // call to default export
      		     <ALIAS_NAME>.<FUNCTION_NAME>();               // call to named export


	0. DEFAULT EXPORT
 	   - There can be a single default export in a .js file (but can be multiple for a module) , others will be named
 	   - Syntax
   	   /* 1. use of default keyword */
   	      export default function (x, y) {
      		return x + y;
   	      }

	0. NAMED EXPORTS
 	   - There can be multiple named exports in a .js file.
 	   - Syntax
   	  /* 1. function , will be exported at end of file */
   	     function subtract (x, y) {
      	        return x - y;
             }

   	  /* 2. function expression , will be exported at end of file */
   	     const multiply = function (x, y) {
                return x * y;
             }

          /* 3. use of 'export' keyword with function */
   	     export const divide = (x, y) => { return x / y};

   	  /* 4. function , will be exported as an alias */
             function sq (x) {
                return x * x;
             }

          /* export functions */
             export { subtract, multiply, sq as square };
	     
	     
Promises
	0.	Consider a code below:
		let ans = f();                 // suppose if f() returns value after a delay of few seconds.
		console.log(ans);              // ans = undefined as code moves to next line and execute it while f() was returning value
		   To avoid this we can use either Callbacks or Promises (preferred)
		   Promises are a way to implement async programming in JavaScript(ES6).
		   A Promise will become a container for future value.
		   The function passed to new Promise is called the EXECUTOR which contains producing code which should eventually produce the result.
		   When new Promise is created, the executor runs automatically.
		   Executor's arguments resolve and reject are callbacks provided by JavaScript itself and should call one of these callbacks:
		     - resolve(respValue) — if the job finished successfully, with result `respValue`.
		     - reject(error)      — if an error occurred, `error` is the error object.
		     The executor should call only one resolve or one reject. Any state change is final. All further calls of resolve or reject are ignored.
		  		   
		   A Promise is always in one of the following states:
		      fulfilled : Action related to the promise succeeded.
		      rejected  : Action related to the promise failed.
		      pending   : Promise is still pending i.e not fulfilled or rejected yet.
		      settled   : Promise has fulfilled or rejected
		      
		   A Promise object serves as link between executor (“producing code”) and consuming functions ("subscribers"), which will receive result or error.
		   Consuming functions can be registered (subscribed) using methods .then(), .catch() and .finally().
		   .then((respData)=> {}, (err)=> {})  : The first argument of .then is a function that runs when the promise is resolved, and receives result.
		                                         The second argument of .then is a function that runs when the promise is rejected, and receives error.
		   .catch((err)=> {}) : can be used for handling the errors(if any). It takes only one function.
		   .finally(()=> {})  : always runs when the promise is settled: be it resolve or reject. It's handler function has no arguments.
		   NOTE : if both i.e., error handler of .then() and error handler of promise .catch() are implemented , error handler of .then() will be called.
		   
		// Example
		function getEmployeeName(id) {
		   return new Promise((resolve, reject) => {
                      if (id <= 3) {
                         resolve(myMap1.get(id));
		      }
                      else {
                         reject(new Error("Invalid employee id"));
		      }
		   });
		}
		function getEmployeeCity(name) {
		   return new Promise((resolve, reject) => {
      			resolve(myMap2.get(name));
  		   });
		}
		function getEmployeeState(city) {
                   return new Promise((resolve, reject) => {
                        resolve(myMap3.get(city));
		   });
		}
		getEmployeeName(empid).then((name) => { getEmployeeCity(name) })
		                      .then((city) => { getEmployeeState(city) })
                                      .then((state) => { console.log(state) })
                                      .catch((error) => { console.log(error) });
				      
	0.	Promise.all
		// Promise.all() method is actually a promise that takes an array of promises(an iterable) as an input. 
		   It returns a single Promise that resolves when all of the promises passed as an iterable, which have resolved or when the iterable contains no promises. 
		   In simple way, if any of the passed-in promises reject, the Promise.all() method asynchronously rejects the value of the promise , whether or not the other promises have resolved.
		   // Example
		   let promises = [];
		   for (let i=0; i<empids.length; i++) {
		       promises.push(getEmployeeName(empids[i]));
		   }
		   Promise.all(promises).then((names) => { console.log(names) })
		                        .catch((error) => { console.log(error) });
					
	0.	Promise.race
	        // returns the first promise that is settled. A settled promise can either be resolved or rejected.
		// Example
		Promise.race(promises).then((name) => { console.log(name) })
  		                      .catch((error) => { console.log(error) });
				      
Async / Await
	0.	There’s a special syntax to work with promises in a more comfortable fashion, called “async/await”.
		"async" keyword can be placed before a function which means function always returns a promise. 
		Other values are wrapped in a resolved promise automatically.
		
		"await" keyword works only inside "async" functions. We will get error if we use "await" inside non-async function.
		The keyword await makes JavaScript wait until that promise settles and returns its result.
		await literally suspends the function execution until the promise settles, and then resumes it with the promise result.
		
		NOTE : If we don’t have try..catch inside async, then promise generated by call of async function() might become rejected. We can append .catch to handle it.
		
		//Example
		async function showAvatar() {
		  // read our JSON
		  try {
                    let response = await fetch('/article/promise-chaining/user.json');
                    let user = await response.json();
		    return user;
		  }
		  catch(err) {
		    console.log(`ERROR ==> ${err.message}`);
		  }
                }
                showAvatar().then((respData)=> {}).catch((err)=> {});
				      
Observables
	0.	// An observable takes the iterable to the asynchronous world. Like an iterable, an observable computes and emits a stream of values. 
	           It is not part of core JS , but provided by thied party library - 'rxjs'
	           However, unlike an iterable, in an observable the calling code does not synchronously pull each value, 
		   but the observable asynchronously pushes each value to the calling code, as soon as it is available.
		   The iterable typically has a next method, which returns the next unread value from the collection. 
		   The calling code can then repeatedly call next in order to read all the values of the collection.
		   eg: On a facebook page it follows infinite scrolling , content gets populated as and when required.
		    - It Emits multiples values
		    - It streams data in multiple pipelines
		    - It Emits its values asynchronously (“push”)
		    - It is cancellable
                    - It is retriable by nature such as retry and retryWhen
                    - It is having array-like operations like map, filter, forEach.. etc



Math
	0.	Math.abs();                                         // absolute value
	0.	Math.ceil();                                        // ceil
	0.	Math.floor();                                       // floor
	0.      Math.round();                                       // round to nearest integer
	0.      Math.E;                                             // Euler's Number (approximately 2.718)
	0.      Math.exp(1);                                        // Return E^x     (Euler's number raised to x (here 1) )
	0.	Math.pow(a,b);                                      // a^b
	0.	Math.sqrt()                                         // square root
	0.      Math.cbrt();                                        // cube root
	0.	Math.random();                                      // generate number [0,1)  // No arg passed
	0.	Math.trunc(879.76);                                 // integer part only , removes decimal
	0.	Math.PI;                                            // PI = 22/7 = 3.14
	0.      Math.max(val1, val2, val3, ...);                    // Maximum of given arguments
	0.      Math.min(val1, val2, val3, ...);                    // Minimum of given args
	0.	Math.log(arg);                                      // natural logarithm of arg
	0.      Math.LN10;                                          // natural logarithm of 10
	0.      Math.log(arg)/Math.LN10;                            // log(arg)/log(10)
	

Alerts
        0.      var resp = prompt("Enter your name","naam");     // returns value entered, first arg is message, second arg is placeholder
	0.	alert(resp);                                     // a message alert
	0.	var cnfstat = confirm("Do you want to exit ?");  // confirmation alert
		if(cnfstat) alert("you said yes !");
		else alert("you said no !");
		
		
CSS
        0.      onclick = this.style.opacity="0.4";
	0.      onclick = this.style.left="+=250px";             // += , -=  specifies CSS properties from current values
	
	
Height/Width of element/screen/window
	0.	elmnt.clientHeight;
		elmnt.clientWidth;				// returns VIEWABLE height/width including padding, but not border, scrollbar or margin.
	0.	elmnt.offsetHeight;
		elmnt.offsetWidth;				// returns VIEWABLE height/width including padding, border, scrollbar, but not margin.
	0.	elmnt.scrollHeight;
		elmnt.scrollWidth;				// returns ENTIRE (including not visible coz of overflow) height/width including padding, but not border, scrollbar or margin.
	0.	screen.availHeight;
		screen.availWidth;				// returns height/width of user screen, minus interface features like Windows Taskbar.
	0.	screen.height;
		screen.width;					// returns total height/width of user screen
	0.	window.innerWidth;
		window.innerHeight;				// returns width/height of window's content area (viewport) including scrollbars
	0.	window.outerWidth;
		window.outerHeight;				// returns width/height of browser window, including all interface elements (like toolbars/scrollbars).


Events
        0.      onclick, ondblclick, onfocus, onblur, onmouseover, onmouseout, onmouseenter, onmouseleave, onmousedown, onmousemove, onmouseup
	0.	onchange, oninput						// onchange occurs when element loses focus, after content has changed.
										// oninput occurs immediately after value of element has changed.
	0.	oncontextmenu                                                   // right click event handler
	0.	oncopy, oncut, onpaste                                          // copy | cut | paste events
	0.	onselect                                                        // works for <input type="file">, <input type="password">, <input type="text">, and <textarea> when text is selcted in them
	0.	// passing EVENT object
		<body onclick="func(event)"><p>paragraph <b>testing</b></p></body>
		- function func(evt) {
		  let elem = evt.target;					// Returns element on which the event originally occurred, eg: <p> OR <b> OR <body>
		  let elem = evt.currentTarget;					// Returns element whose event listener triggered event, eg: <body>
		}
	0.	// passing THIS object
		<body onclick="func(this)"><p>paragraph <b>testing</b></p></body>
									        // Same as event.currentTarget, Returns element whose event listener triggered event, eg: <body>
	0.	onkeydown="keydown(event)", onkeypress="keypress(event)", onkeyup="keyup(event)", oninput="input(event)"  
	        // "event" provides a context object to event which triggered the function
		// keyCode  : A number which represents an actual key on the keyboard ( 'w' code is same as 'W' ) (keydown | keyup) OR 
		              A number which represents an ASCII character ( 'w' code is different from 'W' )     (keypress)
	        // which    : similar to keyCode , suitable for CROSS BROWSER SUPPORT
		// charCode : charCode with onkeydown or onkeyup events, the returned value is always "0".
		              Returns the Unicode character code (a=97 ... ) of the key that triggered the onkeypress event
	        // keydown or keyup is used to find out if the user is pressing a function key (e.g. "F1", "CAPS LOCK" or "Home")
		// keypress works only for alphanumeric and not special keys like ALT, CTRL, SHIFT, ESC or To find out if user is pressing a printable key (e.g. "a" or "5")
		
                function keydown(evt){                                           // first
			var x = evt.which || evt.charCode || evt.keyCode;
			console.log("keydown : " + x)
		}
		function keypress(evt){                                         // second
			var x = evt.which || evt.charCode || evt.keyCode;
			console.log("keypress : " + x);  
			                                                      
		}
		function keyup(evt){                                            // third
			var x = evt.which || evt.charCode || evt.keyCode;
			console.log("keyup : " + x)
		}
	
	0.	event.clientX                                           // horizontal/vertical coordinate (according to client area) of mouse pointer in pixels
		event.clientY                                              // client area is the current window.
	0.	event.pageX                                             // horizontal/vertical coordinate (according to document) of mouse pointer in pixels
		event.pageY                                                // document is the web page.
	0.	event.screenX                                           // horizontal/vertical coordinate (according to users computer screen) of mouse pointer in pixels
		event.screenY
	       
        0.     preventDefault()
		/* 1. preventDefault() method stops the default action of an element from happening. */
	       $("a").click(function(evt){
	          	evt.preventDefault();  
		  });                             
		/* 2. Prevent number from being written to type="text" input */
		<input type="text" onkeypress="chkFn(event)"/>
		function chkFn(evt) {
  			console.log(`${evt.charCode} , ${typeof(evt.charCode)}`);
  			if(evt.charCode >= 48 && evt.charCode <=57) {
   				evt.preventDefault();
  			}
		}
		
		  
        0.     addEventListener()                                        // addEventListener() method attaches an event handler to the specified element.
	       document.getElementById("myBtn").addEventListener("mouseover", myFunction);
	       document.getElementById("myBtn").addEventListener("click", someOtherFunction);   // same/different event attached with same/different function
	       document.getElementById("myBtn").addEventListener("mouseout", OtherFunction);
	       document.getElementById("myBtn").addEventListener("click", function() { myFunction(p1, p2); });
	       document.getElementById("myDIV").removeEventListener("mousemove", myFunction);   // name of the event to remove,function to remove.
	       document.addEventListener("click", myFunction);          // attaches an event handler to the document , here myFunction gets called , anywhere user clicks on document.
	       
	0.	Event Propagation
		Event propagation is a way of defining the element order when an event occurs. 
		Example : If you have a <p> element inside a <div> element, and the user clicks on the <p> element,
		          which element's "click" event should be handled first?
		There are two ways of event propagation in the HTML DOM, bubbling and capturing.
		- In bubbling the inner most element's event is handled first and then the outer.
		  Example : the <p> element's click event is handled first, then the <div> element's click event.

		- In capturing the outer most element's event is handled first and then the inner.
		  Example : the <div> element's click event will be handled first, then the <p> element's click event.
		  
		With addEventListener() specify propagation type by using boolean "useCapture" as third parameter. true  : Capturing mode , false : Bubbling mode
		The default value is false, which will use the bubbling propagation
		NOTE : Propagation to/from child/parent depends on "useCapture" defined on respective child's PARENT element.
		Example : Three divs HTML   <div id="div1"><div id="div2"><div id="div3">INNER</div></div></div>
		document.getElementById("div1").addEventListener("click", function() {
			alert("You clicked the white element!");
		});
		document.getElementById("div2").addEventListener("click", function() {
  			alert("You clicked the orange element!");
		}, false);
		document.getElementById("div3").addEventListener("click", function() {
  			alert("You clicked the outer element!");
		}, true);
	       
	0.      stopPropagation()
	        <div onclick="func2()">DIV 2
	             <div onclick="func1(event)">DIV 1</div>            // Because DIV 1 is inside Div 2, both DIVs get clicked when you click on DIV 1.
	        </div>                                                  // stopPropagation() method prevents propagation of the same event from being called.
                                                                        // Propagation means bubbling up to parent elements or capturing down to child elements.
	       function func1(evt) { alert("DIV 1"); evt.stopPropagation(); }
	       
	      
EVENT LOOP model in JS
==========================
REFERENCE : https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop
                CALL STACK <--> MESSAGE QUEUE
	            ^--         --^
	               EVENT LOOP
- Heap
Objects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.

- Queue
JavaScript runtime uses message queue, which is a list of messages to be processed. 
Each message has an associated function which gets called in order to handle the message.
- Messages are added anytime an event occurs and there is an event listener attached to it. If there is no listener, the event is lost.
  So a click on an element with a click event handler will add a message.
- The message is removed from the queue and its corresponding function is called.
  As always, calling a function creates a new stack frame for that function's use.
  The processing of functions continues until the stack is once again empty. Then, event loop will process next message in queue (if there is one).

- Stack
Function calls form a stack of frames.
When first function calls second function, a second frame is created and pushed on top of the first one.
When second function returns, top frame element is popped out of the stack (leaving only first function's call frame). When first function returns, stack is empty.

- Event Loop
It waits synchronously for a message to arrive (if one is not already available and waiting to be handled).
"Event Loop" looks for when "Call Stack" becomes empty and "Message Queue" has entry in it then dequeue message from "Message Queue" and push into "Call Stack".


setTimeout | setInterval
==========================
	NOTE : When a function is passed in setInterval/setTimeout, an internal reference is created to it and saved in the scheduler. 
	       It prevents the function from being garbage collected, even if there are no other references to it.
	       For setTimeout  the function stays in memory until the scheduler calls it or clearTimeout() is called.
	       For setInterval the function stays in memory until clearInterval() is called.
	       Any setTimeout/setInterval will run only after the current script has finished.
	       Even a zero delay scheduling with setTimeout(func, 0) (the same as setTimeout(func)) is scheduled only after the current script is complete.
	       The setTimeout needs to wait for all the code for queued messages to complete
	       It is possible that func's execution turns out to be longer than we expected and takes more than 'delay' ms.
	       	       
	       Q. How setTimeout and setInterval works in execution loop ?
	       Ans : Javascript is singled-threaded but the browser is not. 
	             Browser has atleast three threads: Javascript engine thread, UI thread, and timing thread, where timing of setTimeout/setInterval are done by timing thread.
		     The delay value represents the (minimum) delay after which the message will actually be pushed into message queue.
		     However, setInterval() has an additional internal "repeat" flag which is set to true.
		     If there is no other message in the queue, and the stack is empty, the message is processed right after the delay. 
		     However, if there are messages, the setTimeout/setInterval message will have to wait for other messages to be processed. 
		     For this reason, the second argument indicates a minimum time—not a guaranteed time.
		     
	       Q. How does browser insure that after execution of script the "setTimeout" will execute ?
	       Ans : When "Call Stack" becomes empty i.e script completes it's execution the "Event Loop" will take message from message queue and push it into stack.
	             The only job of "Event Loop" is when "Call Stack" becomes empty and "Message Queue" has entry in it then dequeue message form "Message Queue" and push into "Call Stack"
	       CALL STACK <--> MESSAGE QUEUE
	            ^--         --^
	               EVENT LOOP
	       
        0.     let timeoutVar = setTimeout(func, duration)                         // calls 'func' only once after 'duration' millisec
	0.     let timeoutVar = setTimeout(function(){ func("First param", "Second param"); }, 2000);        // pass parameters to func
	0.     clearTimeout(timeoutVar);                                  // pass in name of variable defined during setTimeout

        0.     let intervalVar = setInterval(func, duration)                       // calls 'func' after every 'duration' millisec
	0.     let intervalVar = setInterval(function(){ func("First param", "Second param"); }, 2000);      // pass parameters to func
        0.     clearInterval(intervalVar)                                // pass in name of variable defined during setInterval


requestAnimationFrame()
===========================
It’s a method that we can use to repeatedly check our page to see if elements are visible, 
while making sure we don’t overload browser by checking thousands of times per second. 
It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
window.requestAnimationFrame() method tells browser to perform an animation and requests that browser calls specified function to update animation before next repaint. 
The method takes a callback as an argument to be invoked before the repaint.
	// IE Fallback for requestAnimationFrame is setTimeout()
	e.g. var scroll = window.requestAnimationFrame || function(callback){ window.setTimeout(callback, 1000/60)};
	     function loop() {}
	     scroll(loop);
It returns a long integer value, the request id, that uniquely identifies the entry in the callback list.
You can pass this value to window.cancelAnimationFrame() to cancel the refresh callback request, i.e. let animationFrameID = scroll(loop);


IntersectionObserver()
============================
Intersection Observer looks at target element’s position in relation to a root element, and when they “intersect”, will return true.
It accepts a callback function that will be called every time when our observed targets enters or leaves the viewport/root or 
when the amount by which the two intersect changes by a requested amount i.e. "If they intersect by somewhere around N%, I need to do something."
We loop through targets, attaching a listener (observe) to each one. 

The Intersection Observer API provides way to asynchronously observe changes in intersection of target element with an ancestor element or with top-level document's viewport.
It allows
	- Lazy-loading of images or other content as a page is scrolled.
	- Implementing "infinite scrolling" web sites, where more and more content is loaded and rendered as you scroll, so that the user doesn't have to flip through pages.
	- Reporting of visibility of advertisements in order to calculate ad revenues.
	- Deciding whether or not to perform tasks or animation processes based on whether or not the user will see the result.

IMPORTANT: Callback function is called when either of these circumstances occur:
	- A target element intersects either device's viewport or a specified element. That specified element is called the root element or root.
	- The first time observer is initially asked to watch target element even if target is currently not visible/intersecting i.e. observer.observe(target);

Instances of IntersectionObserverEntry are delivered to an IntersectionObserver callback in its entries parameter
	- entry.boundingClientRect
	- entry.intersectionRect
	- entry.rootBounds
	- entry.time
	- entry.intersectionRatio
	  The degree of intersection between the target element and its root is the intersection ratio. 
	  This is a representation of the percentage of the target element which is visible as a value between 0.0 and 1.0.
	- entry.isIntersecting
	  A Boolean value which is true if the target element intersects with the intersection observer's root. 
	  If this is true, then, the IntersectionObserverEntry describes a transition into a state of intersection; 
	  if it's false, then you know the transition is from intersecting to not-intersecting.
	- entry.target
	  The Element whose intersection with the root changed.

Intersection observer options
	- root
	  The element that is used as the viewport for checking visibility of the target. Must be the ancestor of the target. 
	  Defaults to the browser viewport if not specified or if null, e.g. {root: document.querySelector('#scrollArea')}
	- rootMargin
	  Margin around the root. Can have values similar to the CSS margin property, e.g. "10px 20px 30px 40px" (top, right, bottom, left).
	  This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections. Defaults to all zeros.
	- threshold
	  Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed. 
	  e.g. If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5. 
	       If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1]. 
	  The default is 0 (meaning as soon as even one pixel is visible, the callback will be run). 
	  A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.
	  
CHECK 'scrollAnimations.html' FILE FOR EXAMPLE OF INTERSECTION OBSERVER.


Page events
==============
	0.	Lifecycle of an HTML page has four important events:
		- DOMContentLoaded – the browser fully loaded HTML, and the DOM tree is built, 
		                     but external resources like pictures <img> and stylesheets may be not yet loaded.
		- load             – not only HTML is loaded, but also all the external resources: images, styles etc.
		- beforeunload     – the user is leaving the page, check if user saved changes and ask whether really want to leave.
		- unload           - the user almost left, but we still can initiate some operations, such as sending out statistics.
	       // Example
	           // 1. NOTE : The DOMContentLoaded event happens on the document object.
		                When the browser processes an HTML-document and comes across a <script> tag, it needs to execute before continuing building the DOM.
		                DOMContentLoaded has to wait except for <script> with the async/defer attribute and 
			        <script> that is generated dynamically with 'document.createElement('script')'
			        Images and other resources may also still continue loading.
		    > document.addEventListener("DOMContentLoaded", functionName);
		  
		   // 2. NOTE : The load event happens on the window object , also on a TAG
	           > window.onload = function() {
		       alert('Page loaded');
		         // image is loaded at this time
		     };
		   > img.onload = () => { console.log('img onload'); };
		   
		   // 3. NOTE : The beforeunload event triggers on window object.
		   		This is fired when browser is to be closed, tab is to be closed, the page is to be reloaded.
		                The event handler should call preventDefault() to show confirmation dialog according to specifications.
				Older browsers may not support this method, so event handler must return a string. This returned string can be empty.
				Some browsers may not show any confirmation boxes unless the user has interacted with the page. 
				This is used to prevent unwanted or malicious websites from creating unnecessary pop-ups. 
				The user may have to interact with the page to see the confirmation message.
		   > window.addEventListener('beforeunload', function (e) { 
            		e.preventDefault(); 
            		e.returnValue = ''; 
        	     });
			     
		   // 4. NOTE : The unload event triggers on window object.
		   		a special 'navigator.sendBeacon(url, data)' method can be used for saving data (mouse clicks, scrolls, viewed page areas, and so on.) on our server.
		   > let analyticsData = { /* object with gathered data */ };
		     window.addEventListener("unload", function() {
  			navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));
	             };
		
		- Page reload
		  > document.location.reload(true)  : force the reloaded page to come from the server (instead of cache). 
		  > document.location.reload(false) : reload the page from the cache. (default, when no true/false given).
		  
	0.	document.readyState
	        // The document.readyState property tells us about the current loading state.
		   There are 3 possible values:
		        "loading"     – the document is loading.
			"interactive" – the document was fully read, happens at about the same time as DOMContentLoaded, but before it.
			"complete"    – the document was fully read and all resources (like images) are loaded too,  same time as window.onload, but before it.
		> if (document.readyState == 'loading') {
		    // loading yet, wait for the event
  		    document.addEventListener('DOMContentLoaded', work);
		} else {
  		    // DOM is ready!
		}
		
	0.	readystatechange() event
	        // readystatechange event that triggers when the state changes
		> document.addEventListener('readystatechange', () => console.log(document.readyState));
		
	
	
Blob  /  FormData  /  File Reader
============================
	/* REFERENCE : https://javascript.info/blob
		     : https://javascript.info/file 
	*/
	0.	In the browser, there are higher-level objects, described in File API, in particular Blob (Binary Large Object).
		let blob = new Blob(blobParts, options);        // options define { type: 'image/png' }
		let url = URL.createObjectURL(blob);            // it takes Blob and returns unique URL for it, in form  blob:<origin>/<uuid>
								// eg: blob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273
		The mapping of URL → Blob is automatically cleared on document unload, so Blob objects are freed then, otherwise use
		URL.revokeObjectURL(url);                      // removes the reference from internal mapping, and memory to be freed.
		HTML
		<!-- download attribute forces browser to download with name of file as of download attr, instead of navigating -->
		<a download="hello.txt" href='#' id="downloadlink">Download</a>
		JS
		document.getElementById("downloadlink").href = makeTextFile(localStorage.getItem("info"));
		let textFileURL = null;
		function makeTextFile(dataArg) {
			let blobData = new Blob([dataArg], {type: 'text/plain'});
			
			// If we are replacing a previously generated file we need to
    			// manually revoke the object URL to avoid memory leaks.
    			if (textFileURL !== null) {
      				window.URL.revokeObjectURL(textFileURL);
    			}

    			textFileURL = window.URL.createObjectURL(blobData);

    			return textFileURL;
		}

	0.	FormData can be used to send files to backend server with POST API.
		It’s encoded and sent out with Content-Type: multipart/form-data
		Eg:-
    			const fileDetails = new FormData();
			let file = new Blob([this.files[0]], {type: 'application/json'});
    			fileDetails.append('file', file, this.fileName);
	
	0.	FileReader is an object with the sole purpose of reading data from Blob (and hence File too) objects.
		It delivers the data using events, as reading from disk (uploaded file) may take time.
		It offers reading methods like  reader.readAsBinaryString | reader.readAsArrayBuffer | reader.readAsText
		HTML
		// NOTE : value (ngModel) attr of type=file is read-only
		<input type="file" (change)="fileChangeFn($event)" [(ngModel)]="filePath">
		JS
		fileChangeFn(ev) {
		  // create fileReader object
		  let reader = new FileReader();
		
		  // For Browsers other than IE.
		  if (reader.readAsBinaryString) {
			// wire up file target
      			let target: DataTransfer = <DataTransfer>(ev.target);
      			if (target.files.length !== 1) throw new Error('Cannot use multiple files');

      			// call READ method of FileReader()
      			reader.readAsBinaryString(target.files[0]);

      			// cancel the operation
      			// reader.abort();

      			// loading started
      			reader.onloadstart = function() {
        			console.log(`READER LOADING STARTED`);
      			};

      			// occurs during reading
      			reader.onprogress = function() {
        			console.log(`READING ...`);
      			};
			
			// no errors, reading complete
      			reader.onload = function() {
          			let data = reader.result;
			};
			
			// abort() called
      			reader.onabort = function() {
        			console.log(`READER ABORTED`);
      			};

      			// error has occurred
      			reader.onerror = function() {
        			console.error(`READER ERROR ==> ${reader.error.message}`);
      			};

      			// reading finished with either success or failure
      			reader.onloadend = function() {
        			console.log(`READER LOADING ENDED`);
      			};
		} else {
      			alert(`Your browser does not support this feature.`);
    		}
	      }
	      
	      
	      
Local Storage / Session Storage / Cookies
=============================================
	0.	The localStorage allow to save key/value pairs in a web browser.
		The localStorage object stores data with no expiration date. 
		The data will not be deleted when browser tab or browser is closed and even OS reboot, and will be available next day, week, or year.
		The localStorage is bound to origin (protocol/domain/port triplet) on all tabs and windows.
		That means if we open same origin (protocol/domain/port, the url path can be different) in a different tab or window we can access all localStorage data for it.
		
		The sessionStorage allow to save key/value pairs in a web browser.
		The sessionStorage object stores data for only one session.
		The data is deleted when the current browser tab is closed, but survives page refresh.
		The sessionStorage is bound to origin (protocol/domain/port triplet) only on current browser tab.
		That means if we open same origin (protocol/domain/port, the url path can be different) in a different tab or window we CANNOT access sessionStorage data for it.
		
		// Methods / Properties (applicable for both localStorage and sessionStorage)
		> localStorage.setItem("keyname", "value");          // Adds key to storage or update key's value if already exists
		> let val = localStorage.getItem("keyname");         // value of the specified key name
		> localStorage.removeItem("keyname");                // Removes that key from the storage
		> sessionStorage.clear();                            // Empty all localStorage/sessionStorage key out of storage
		> let len = sessionStorage.length;                   // Number of items stored in browsers localStorage/sessionStorage Object for this particular domain
		> let keyname = sessionStorage.key(index);           // Name of the key with the specified index.
		
	0.	Cookies are small strings of data that are stored directly in the browser.
		When a browser requests a web page from a server, cookies belonging to the page are added to the request. 
		This way the server gets the necessary data to "remember" information about users.
		NOTE : This will not work if browser has local cookies support turned off.
		CREATE/UPDATE
		A write operation to document.cookie adds/updates only cookies mentioned in it, but doesn’t touch other cookies.
		name=value;     : cookie pair
		path=/pathVAL;  : cookie will be accessible for pages under this path.
				  Must be absolute. By default, it’s the current path.
				  If a cookie is set with path=/admin, it’s visible at pages /admin and /admin/something, but not at /home or /adminpage.
				  Usually, we should set path to the root: path=/ to make the cookie accessible from all website pages.
		expires=TIME;   : cookies disappears when browser is closed. Such cookies are called “session cookies”.
				  To let cookies survive browser close, we can set either expires or max-age option.
				  The date must be exactly in this format, in GMT timezone. We can use date.toUTCString() for this.
		max-age=SECS;   : An alternative to expires, specifies the cookie expiration in seconds from the current moment.
		eg: document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT;"
		READ
		The value of `document.cookie` consists of name=value pairs, delimited by  ';'  and each one is a separate cookie.
		eg: console.log(`COOKIES ==> ${document.cookie}`);          // cookie1=value; cookie2=value; cookie3=value;
		DELETE
		You don't have to specify a cookie value when you delete a cookie.
		Just set the expires parameter to an already passed date OR max-age parameter to 0 or NEGATIVE VALUE.
		You should define the cookie path to ensure that you delete the right cookie.
		Some browsers will not let you delete a cookie if you don't specify the path.
		eg: document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
		
	

Console
	0.	console.assert(expression, message);                     // writes message to console, only if expression evaluates to false or null.
	0.	console.error(message);                                  // writes an error message to the console (highlighted in RED)
	0.	console.info(message);                                   // writes a message to the console.
	0.	console.log(message);                                    // writes a message to the console.
	0.	console.table(tabledata, tablecolumns);                  // first parameter must be JSON object or array ,containing data to fill the table. 
	                                                                   // An array containing names of columns to be displayed in table ie act as filter. eg : console.table([car1, car2, car3]);  where car1, car2, car3 are JSON objects.
	0.	console.warn(message);                                   // writes a warning to the console.
	0.	console.clear();                                         // clears console plus write message in console: "Console was cleared".
	0.	console.count(label);                                    // number of times particular console.count() with defined label is called
	0.	console.group(label);                                    // indicates the start of a not-collapsed message group. All messages will from now on be written inside this group.
	0.	console.groupCollapsed(label);                           // indicates the start of a collapsed message group. Click the expand button to open the message group.
	0.	console.groupEnd();                                      // indicates the end of a message group.
	0.	console.time(label);                                     // starts a timer with particular LABEL in console view.
	0.	console.timeEnd(label);                                  // ends a timer with particular LABEL, and write result in console view.
	0.      console.log(`${VARIABLE} value`);                        // value of variable using backticks and ${}
	0.	console.trace("Trace");					 // stack trace of code execution flow at that point. It provides file names, functions, line numbers. 
	
	
DOM Document
	0.	document.activeElement.tagName;                          // returns the currently focused element in the document.
	0.	document.documentURI;                                    // returns the location of a document.
	0.	document.body;                                           // BODY of document as selector
	0.	document.getElementById("idval")	                 // Returns the element that has the specified ID attribute
 	0.	document.getElementsByClassName("classval");             // Returns NodeList containing all elements with the specified CLASS attribute
	0.	document.getElementsByName("nameval");                   // Returns NodeList containing all elements with a specified NAME attribute
	0.	document.getElementsByTagName("tagval");                 // Returns NodeList containing all elements with the specified tag name
	0.	document.hasFocus();                                     // Returns Boolean value indicating whether the document has focus
	0.	document.querySelector("#IDVAL");                        // Returns first element that matches specified CSS selector(s) in document
	0.	document.querySelectorAll("#IDVAL");                     // Returns NodeList containing all elements that matches specified CSS selector(s) in document
	0.	document.title;                                          // Sets or returns the title of the document
	0.	document.write();                                        // Writes HTML expressions or JavaScript code to a document
	0.	document.writeln();                                      // Same as write(), but adds a newline character after each statement
	0.	let btn = document.createElement("BUTTON");		 // returns created Element node object || btn.innerHTML = "CLICK ME"; document.body.appendChild(btn);
	0.	let t = document.createTextNode("Hello World");          // returns created Text node object    || let h = document.createElement("H1"); h.appendChild(t);
	
	
DOM Element
	0.	elem.appendChild(elemNodeObject);                        // Adds new child node to an element as last child node , returns appended child(elemNodeObject)
									 // NOTE : If the given child is a reference to an existing node in the document, 
									 // appendChild() moves it from its current position to the new position
									 // (thus, there is no requirement to remove node before appending it to some other node).
		elem.removeChild(elemNodeObject);                        // Removes child node from DOM and returns removed node(elemNodeObject), it preserves EventListeners
		                                           		 // we may reuse removed node later by storing returned object in variable.
									 // eg1:remove node without specifying its parent=if(node.parentNode){node.parentNode.removeChild(node)} 
									 // eg2:remove all nodes from element=while(element.firstChild){element.removeChild(element.firstChild)}
		elem.replaceChild(newChild, oldChild);			 // replaces a child node , returns replaced node i.e. oldChild
									 // if newChild already exists in DOM, it is removed from current position and then replaces oldChild
		elem.insertBefore(newNode, referenceNode);		 // inserts newNode before referenceNode as child of elem , returns newly added child(newNode)
									 // if newNode already exists in DOM, it is removed from current position & then insertedBefore refNode
									 // referenceNode must be Node or null (if null, newNode is inserted at end)
									 // There's no insertAfter() method but we can do `elem.insertBefore(newNode,referenceNode.nextSibling)`
	0.	elem.innerHTML;                                          // Sets/returns content of element, just like html() in jQuery
		elem.innerText;                                          // Sets/returns text content of node and descendants, text() in jQuery
	0.	elem.parentNode;					 // returns the parent of the specified node in the DOM tree. `document` parentNode is null.
		elem.firstChild;					 // returns node's first child or null if node has no children. returns #text or #comment nodes as well
		elem.firstElementChild;					 // returns only first ELEMENT node or null. NOT text and comments
		elem.lastChild;						 // returns node's last child or null if there are no child. returns #text or #comment nodes as well
		elem.lastElementChild;					 // returns only last ELEMENT node or null. NOT text and comments
		elem.childNodes;					 // returns NodeList of child nodes of elem. Child nodes include elements, #text and #comments nodes
		elem.children;						 // returns NodeList of only child ELEMENTS of elem. NOT text and comments
		elem.nextSibling;					 // returns node immediately following elem in parent's childNodes list or null if it is last in list.
		elem.nextElementSibling;				 // returns only ELEMENT node. NOT text and comments
		elem.previousSibling;					 // returns node immediately preceding elem in parent's childNodes list or null if it is first in list.
		elem.previousElementSibling;				 // returns only ELEMENT node. NOT text and comments
		elem.cloneNode(true);                                    // returns duplicate of element(elem) node
		                         				 // false(default) only node cloned, empty node <elem></elem> | true(deep copy), node and its subtree
									 // copies all inline event listeners, attributes-values(may cause duplicate element IDs in document). 
									 // does NOT copy event listeners added using addEventListener() or assigned (node.onclick=someFunction)
		elem.remove();						 // removes the node object from DOM tree
		elem.replaceWith(newChild);				 // replaces the node object with newChild
		elem.before(newNode);					 // inserts Node objects in children list of this elem's parent, just BEFORE this elem
		elem.after(newNode);					 // inserts Node objects in children list of this elem's parent, just AFTER this elem
	0.	elem.blur();                                             // Removes focus from an element
	0.	elem.focus();                                            // Gives focus to an element
	0.	elem.click();						 // Simulates a mouse-click on an element
	0.	elem.select();						 // Simulates select all (`ctrl+A`) on text field 
	0. 	elem.contentEditable;                                    // sets/returns whether content of element is editable or not, similar to "contentEditable" attribute in HTML
	0.	elem.classList;                                          // Returns the class name(s) of an element
	0.	elem.classList.remove("classval");                       // just like removeClass("classval") in jQuery
	0.	elem.classList.add("classval");                          // just like addClass("classval") in jQuery
	0.	elem.classList.toggle("classval");                       // just like toggleClass("classval") in jQuery
	0.	elem.className;                                          // Sets or returns value of CLASS attribute of an element
	0.	elem.getAttribute("attrname");                           // just like attr("attrname") in jQuery
	0.	elem.setAttribute("attrname", "attrval");                // just like attr({"attrname" : "attrval"}) in jQuery
	0.	elem.removeAttribute("attrname");			 // removes the specified attribute from an element.
	0.	elem.scrollTop;
		elem.scrollLeft;					 // Sets or returns px element's content is scrolled vertically/horizontally
		elem.scrollIntoView();					//  scrolls element's parent container such that element on which scrollIntoView() is called is visible to user
		element.scrollIntoView(alignToTop); 			//  Boolean parameter , (true = top | false = bottom) of element will be aligned to top/bottom of visible area of scrollable ancestor.
		element.scrollIntoView(scrollIntoViewOptions); 		//  Object parameter , eg: {behavior: "smooth", block: "end", inline: "nearest"}
										 behavior - transition animation (auto or smooth | default - auto)
										 block  - vertical alignment (start, center, end, or nearest | default - start)
										 inline   - horizontal alignment (start, center, end, or nearest | default - nearest)
	0.	elem.style.PROP="PROPVAL";                               // just like css({"PROP" : "PROPVAL"}) in jQuery
	
	
￼
